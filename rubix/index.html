<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rubik's Cube Web Simulator (3x3–10x10)</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#121821; --ink:#e7edf5; --muted:#9fb0c6; --accent:#3aa3ff;
      --btn:#1b2532; --btn2:#223044; --good:#2ecc71; --warn:#ffb020; --bad:#ff5c5c;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif}
    .app{display:grid; grid-template-columns: 320px 1fr; grid-template-rows:auto 1fr; height:100%}
    header{grid-column:1/-1; padding:10px 14px; display:flex; gap:12px; align-items:center; background:linear-gradient(180deg, #0e131a, #0b0f14)}
    header h1{font-size:16px; margin:0; font-weight:600}
    header .sub{color:var(--muted); font-size:12px}
    .left{background:var(--panel); border-right:1px solid #1a2230; display:flex; flex-direction:column; overflow:auto}
    .section{padding:12px 14px; border-bottom:1px solid #151d29}
    .section h2{margin:0 0 10px 0; font-size:13px; letter-spacing:.3px; color:#c9d6ea; text-transform:uppercase}
    .row{display:flex; gap:8px; align-items:center; margin:8px 0}
    .row label{min-width:96px; color:var(--muted)}
    input[type="number"], select, input[type="text"]{background:var(--btn); color:var(--ink); border:1px solid #233044; border-radius:8px; padding:6px 8px; outline:none}
    input[type="color"]{width:28px; height:28px; border:none; background:none}
    button{background:var(--btn2); color:var(--ink); border:1px solid #2a3a52; border-radius:12px; padding:8px 12px; cursor:pointer}
    button:hover{filter:brightness(1.1)}
    button:active{transform:translateY(1px)}
    .btn-row{display:flex; gap:8px; flex-wrap:wrap}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0b1522; border:1px solid #223148; border-radius:6px; padding:2px 6px; color:#cfe1ff}
    .history{height:140px; overflow:auto; background:#0c131c; border:1px solid #223148; border-radius:10px; padding:8px;}
    .history .moves{word-wrap:break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .canvas-wrap{position:relative}
    canvas{display:block; width:100%; height:100%; background:radial-gradient(1000px 700px at 60% 40%, #0e1622, #0a0e14)}
    .toast{position:absolute; left:12px; bottom:12px; padding:8px 12px; background:#0d1724cc; border:1px solid #284163; border-radius:10px; color:#cfe1ff}
    .grid{display:grid; grid-template-columns: repeat(3, 1fr); gap:6px}
    .muted{color:var(--muted)}
    .small{font-size:12px}
    .link{color:var(--accent); cursor:pointer}
  </style>
</head>
<body>
<div class="app">
  <header>
    <h1>Rubik's Cube Web Simulator</h1>
    <div class="sub">3D canvas • 3×3 to 10×10 • moves, scramble, undo/redo, basic solver</div>
  </header>
  <aside class="left">
    <div class="section">
      <h2>Setup</h2>
      <div class="row"><label>Cube Size</label>
        <input id="sizeInput" type="number" min="3" max="10" step="1" value="3" />
        <button id="applySizeBtn">Apply</button>
      </div>
      <div class="row"><label>Presets</label>
        <select id="presetSelect">
          <option value="solved">Solved</option>
          <option value="checker">Checkerboard</option>
          <option value="stripes">Stripes</option>
          <option value="cross">Cross</option>
        </select>
        <button id="applyPresetBtn">Apply</button>
      </div>
      <div class="row"><label>Sticker Gap</label>
        <input id="gapInput" type="number" min="0" max="0.2" step="0.01" value="0.04" />
      </div>
    </div>

    <div class="section">
      <h2>Colors</h2>
      <div class="grid small">
        <div>Up (U)</div><div>Right (R)</div><div>Front (F)</div>
        <input type="color" id="colU" value="#ffffff" />
        <input type="color" id="colR" value="#ff6b00" />
        <input type="color" id="colF" value="#00d84a" />
        <div>Down (D)</div><div>Left (L)</div><div>Back (B)</div>
        <input type="color" id="colD" value="#ffff00" />
        <input type="color" id="colL" value="#ff0000" />
        <input type="color" id="colB" value="#006cff" />
        <button id="applyColorsBtn" style="grid-column:1/4">Apply Colors</button>
      </div>
    </div>

    <div class="section">
      <h2>Controls</h2>
      <div class="btn-row">
        <button id="resetBtn">Reset</button>
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>
      <div class="row">
        <label>Scramble</label>
        <input id="scrambleLen" type="number" min="10" max="200" step="1" value="25" />
        <button id="scrambleBtn">Go</button>
      </div>
      <div class="row">
        <label>Solve</label>
        <button id="solveBtn">Auto‑solve</button>
      </div>
      <div class="small muted">Keyboard: <span class="kbd">F B L R U D</span> + optional <span class="kbd">'</span> for counter‑clockwise and <span class="kbd">2</span> for double. <span class="kbd">Z/X</span> to rotate view. <span class="kbd">Space</span> resets view. <span class="kbd">+</span>/<span class="kbd">-</span> zooms.</div>
    </div>

    <div class="section">
      <h2>Move History</h2>
      <div class="history"><div id="historyMoves" class="moves"></div></div>
      <div class="small muted">Click a move to undo back to that point.</div>
    </div>

    <div class="section">
      <h2>Instructions</h2>
      <div class="small">
        <p>1) Choose cube size (3–10) and press <b>Apply</b>. 2) Use buttons or the keyboard to perform moves. 3) <b>Scramble</b> then <b>Auto‑solve</b> (works best on 3×3).</p>
        <p>To host on your website, upload this single <span class="kbd">index.html</span> file. No external libraries are required.</p>
      </div>
    </div>
  </aside>

  <main class="canvas-wrap">
    <canvas id="view"></canvas>
    <div class="toast small" id="toast">Ready.</div>
  </main>
</div>

<script>
/**
 * Rubik's Cube Web Simulator (self‑contained, no external libs)
 * - Canvas 2D renderer with a tiny 3D pipeline (matrices + projection + painter's algo)
 * - Supports NxN (3..10) surface stickers; smooth layer animations
 * - Core moves: F,B,L,R,U,D with ', 2
 * - Scramble / Undo / Redo / History
 * - Basic beginner solver for 3x3 (not optimal, but reliable). Shows move count.
 *
 * NOTE on scope: Rendering is of the OUTER SURFACE stickers only (hollow cube). This lets
 * large NxN perform well while still mapping exactly to legal face turns.
 */

/*************************
 * Math helpers (Vec/Mat)
 *************************/
const EPS = 1e-6;
function rad(a){return a*Math.PI/180}
function matIdent(){return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]}
function matMul(a,b){
  const r=new Array(16).fill(0);
  for(let row=0;row<4;row++) for(let col=0;col<4;col++){
    for(let k=0;k<4;k++) r[row*4+col]+=a[row*4+k]*b[k*4+col];
  }
  return r;
}
function matTranslate(x,y,z){const m=matIdent(); m[12]=x; m[13]=y; m[14]=z; return m}
function matScale(x,y,z){return [x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]}
function matRotX(a){const c=Math.cos(a), s=Math.sin(a);return [1,0,0,0, 0,c,-s,0, 0,s,c,0, 0,0,0,1]}
function matRotY(a){const c=Math.cos(a), s=Math.sin(a);return [c,0,s,0, 0,1,0,0, -s,0,c,0, 0,0,0,1]}
function matRotZ(a){const c=Math.cos(a), s=Math.sin(a);return [c,-s,0,0, s,c,0,0, 0,0,1,0, 0,0,0,1]}
function vecTransform(m, v){
  const [x,y,z,w=1]=v; return [
    m[0]*x+m[4]*y+m[8]*z+m[12]*w,
    m[1]*x+m[5]*y+m[9]*z+m[13]*w,
    m[2]*x+m[6]*y+m[10]*z+m[14]*w,
    m[3]*x+m[7]*y+m[11]*z+m[15]*w
  ];
}

/*****************
 * Renderer (2D)
 *****************/
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let W=0,H=0;
function resize(){
  const dpr = window.devicePixelRatio||1; const rect=canvas.getBoundingClientRect();
  W=Math.max(600, rect.width|0); H=Math.max(400, rect.height|0);
  canvas.width=W*dpr; canvas.height=H*dpr; canvas.style.width=W+'px'; canvas.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

/************************
 * Cube Model & Stickers
 ************************/
const FACE = {U:0,R:1,F:2,D:3,L:4,B:5};
const FACE_NAMES = ['U','R','F','D','L','B'];
let FACE_COLORS = {
  U:'#ffffff', R:'#ff6b00', F:'#00d84a', D:'#ffff00', L:'#ff0000', B:'#006cff'
};

function defaultColors(){
  return {U:colU.value,R:colR.value,F:colF.value,D:colD.value,L:colL.value,B:colB.value};
}

let N = 3; // size
let GAP = parseFloat(document.getElementById('gapInput').value);

// State as 6 faces of N x N stickers storing face keys 'U','R',... not hex.
let state = null;

function makeSolved(n){
  const s={}; for(const f of Object.keys(FACE)){
    s[f]=Array.from({length:n},()=>Array.from({length:n},()=>f));
  } return s;
}

// Geometry for stickers: we build quads centered on each face cell in [-1,1]^3 cube.
let stickers = []; // array of {face, i, j, quad:[[x,y,z]x4], color}

function buildStickers(){
  stickers = [];
  const n=N; const step = 2/n; const pad = GAP*step; const tile = step - pad;
  const start = -1 + step/2;
  function pushFace(face, normalAxis, normalSign, uAxis, vAxis){
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        const center = {x:0,y:0,z:0};
        center[normalAxis] = normalSign*1;
        center[uAxis] = start + j*step;
        center[vAxis] = start + i*step;
        const du = {x:0,y:0,z:0}; du[uAxis]=tile/2;
        const dv = {x:0,y:0,z:0}; dv[vAxis]=tile/2;
        // quad corners (ccw)
        const p1=[center.x-du.x-dv.x, center.y-du.y-dv.y, center.z-du.z-dv.z];
        const p2=[center.x+du.x-dv.x, center.y+du.y-dv.y, center.z+du.z-dv.z];
        const p3=[center.x+du.x+dv.x, center.y+du.y+dv.y, center.z+du.z+dv.z];
        const p4=[center.x-du.x+dv.x, center.y-du.y+dv.y, center.z-du.z+dv.z];
        stickers.push({face, i, j, quad:[p1,p2,p3,p4]});
      }
    }
  }
  pushFace('U','y',+1,'x','z');
  pushFace('D','y',-1,'x','z');
  pushFace('F','z',+1,'x','y');
  pushFace('B','z',-1,'x','y');
  pushFace('R','x',+1,'z','y');
  pushFace('L','x',-1,'z','y');
}

/*****************
 * Camera / View
 *****************/
let camera = {dist: 4.2, rotX: rad(30), rotY: rad(35)};
function viewMatrix(){
  const T = matTranslate(0,0,-camera.dist);
  const RX=matRotX(camera.rotX), RY=matRotY(camera.rotY);
  return matMul(T, matMul(RX, RY));
}
function project(v){
  // simple perspective
  const fov = rad(55); const f = 1/Math.tan(fov/2); const aspect=W/H; const znear=0.1, zfar=100;
  const P=[f/aspect,0,0,0, 0,f,0,0, 0,0,(zfar+znear)/(znear-zfar),-1, 0,0,(2*zfar*znear)/(znear-zfar),0];
  const mvp = matMul(P, viewMatrix());
  const o = vecTransform(mvp, [...v,1]);
  if(Math.abs(o[3])<EPS) return null; const x=o[0]/o[3], y=o[1]/o[3], z=o[2]/o[3];
  return {x:(x*0.5+0.5)*W, y:(-y*0.5+0.5)*H, z};
}

/*****************
 * Interaction
 *****************/
let dragging=false, lastX=0,lastY=0;
canvas.addEventListener('mousedown', e=>{dragging=true; lastX=e.clientX; lastY=e.clientY});
window.addEventListener('mouseup', ()=>dragging=false);
window.addEventListener('mousemove', e=>{
  if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY;
  camera.rotY += dx*0.01; camera.rotX += dy*0.01; camera.rotX=Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, camera.rotX));
});

// Mouse/trackpad wheel zoom (two-finger scroll on macOS trackpads also triggers this)
window.addEventListener('wheel', e=>{
  camera.dist=Math.max(2.2, Math.min(14, camera.dist + e.deltaY*0.0015));
},{passive:true});

// Keyboard controls
window.addEventListener('keydown', e=>{
  if(animating) return; // block during animations
  if(e.code==='Space'){camera.rotX=rad(30); camera.rotY=rad(35); e.preventDefault();}
  if(e.key==='z' || e.key==='Z'){camera.rotY-=0.12}
  if(e.key==='x' || e.key==='X'){camera.rotY+=0.12}
  // New: keyboard zoom for laptops/trackpads without wheel
  if(e.key==='+' || e.key==='=') { camera.dist=Math.max(2.2, camera.dist - 0.15); }
  if(e.key==='-' || e.key==='_') { camera.dist=Math.min(14,  camera.dist + 0.15); }
  const k=e.key.toUpperCase(); if('FBLRUD'.includes(k)){
    let mod=""; if(e.shiftKey || e.key==="'") mod="'"; if(e.altKey || e.metaKey || e.ctrlKey) mod='2';
    queuedMove = k+mod; performMove(k+mod, true);
  } else if(e.key==="'" && queuedMove && !queuedMove.includes("'")) { performMove(queuedMove+"'", true); queuedMove=null; }
    else if(e.key==='2' && queuedMove && !queuedMove.includes('2')) { performMove(queuedMove+'2', true); queuedMove=null; }
});
let queuedMove=null;

// Pinch zoom (touchscreens / some trackpads)
let lastTouchDist=null;
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    lastTouchDist = Math.hypot(dx,dy);
  }
},{passive:true});
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const dist = Math.hypot(dx,dy);
    if(lastTouchDist){
      const delta = lastTouchDist - dist;
      camera.dist = Math.max(2.2, Math.min(14, camera.dist + delta*0.005));
    }
    lastTouchDist = dist;
  }
},{passive:true});
canvas.addEventListener('touchend', ()=>{ lastTouchDist=null; }, {passive:true});

/**********************
 * Moves & Animations
 **********************/
let history=[], future=[]; // stacks of move strings
const toast = document.getElementById('toast');
function setToast(t){toast.textContent=t}

let animating=false; let animStart=0; let animAngle=0; let animMove=null; let animDuration=140; // ms

function rotateFaceArray(face, prime=false, double=false){
  // rotate NxN array in place; adjacent strip swaps handled separately
  const a=state[face]; const n=a.length; const times = double?2:(prime?3:1);
  for(let t=0;t<times;t++){
    const b=Array.from({length:n},()=>Array(n));
    for(let i=0;i<n;i++) for(let j=0;j<n;j++) b[j][n-1-i]=a[i][j];
    state[face]=b;
  }
}

function performMove(move, pushHist=false){
  // move like "R", "R'", "R2"
  const m=move[0]; const prime=move.includes("'"); const dbl=move.includes('2');
  if(animating) return;
  animating=true; animStart=performance.now(); animMove={m,prime,dbl}; animAngle=0;
  if(pushHist){ history.push(move); future.length=0; updateHistory(); }
}

function applyMoveState(m, prime=false, dbl=false){
  const n=N; const times = dbl?2:(prime?3:1);
  const F=state;
  function cycle(arr, times){for(let t=0;t<times;t++){arr.unshift(arr.pop())}}
  // helper to extract and set edge strips
  function getRow(face, i){return [...F[face][i]]}
  function setRow(face, i, row){F[face][i]=[...row]}
  function getCol(face, j){return F[face].map(r=>r[j])}
  function setCol(face, j, col){for(let i=0;i<n;i++)F[face][i][j]=col[i]}

  switch(m){
    case 'U': rotateFaceArray('U', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getRow('B',0), b=getRow('R',0), c=getRow('F',0), d=getRow('L',0);
        if(!prime){ setRow('B',0,d); setRow('R',0,a); setRow('F',0,b); setRow('L',0,c); }
        else{ setRow('B',0,b); setRow('R',0,c); setRow('F',0,d); setRow('L',0,a); }
      } break;
    case 'D': rotateFaceArray('D', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getRow('F',n-1), b=getRow('R',n-1), c=getRow('B',n-1), d=getRow('L',n-1);
        if(!prime){ setRow('F',n-1,b); setRow('R',n-1,c); setRow('B',n-1,d); setRow('L',n-1,a); }
        else{ setRow('F',n-1,d); setRow('R',n-1,a); setRow('B',n-1,b); setRow('L',n-1,c); }
      } break;
    case 'F': rotateFaceArray('F', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getRow('U',n-1), b=getCol('R',0), c=getRow('D',0), d=getCol('L',n-1);
        if(!prime){ setRow('U',n-1, d.slice().reverse()); setCol('R',0, a); setRow('D',0, b.slice().reverse()); setCol('L',n-1, c); }
        else{ setRow('U',n-1, b); setCol('R',0, c.slice().reverse()); setRow('D',0, d); setCol('L',n-1, a.slice().reverse()); }
      } break;
    case 'B': rotateFaceArray('B', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getRow('U',0), b=getCol('L',0), c=getRow('D',n-1), d=getCol('R',n-1);
        if(!prime){ setRow('U',0, b.slice().reverse()); setCol('L',0, c); setRow('D',n-1, d.slice().reverse()); setCol('R',n-1, a); }
        else{ setRow('U',0, d); setCol('L',0, a.slice().reverse()); setRow('D',n-1, b); setCol('R',n-1, c.slice().reverse()); }
      } break;
    case 'R': rotateFaceArray('R', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getCol('U',n-1), b=getCol('F',n-1), c=getCol('D',n-1), d=getCol('B',0);
        if(!prime){ setCol('U',n-1, d.slice().reverse()); setCol('F',n-1, a); setCol('D',n-1, b); setCol('B',0, c.slice().reverse()); }
        else{ setCol('U',n-1, b); setCol('F',n-1, c); setCol('D',n-1, d.slice().reverse()); setCol('B',0, a.slice().reverse()); }
      } break;
    case 'L': rotateFaceArray('L', prime, dbl);
      for(let t=0;t<times;t++){
        const a=getCol('U',0), b=getCol('B',n-1), c=getCol('D',0), d=getCol('F',0);
        if(!prime){ setCol('U',0, b.slice().reverse()); setCol('B',n-1, c.slice().reverse()); setCol('D',0, d); setCol('F',0, a); }
        else{ setCol('U',0, d); setCol('B',n-1, a.slice().reverse()); setCol('D',0, b.slice().reverse()); setCol('F',0, c); }
      } break;
  }
}

function isStickerOnLayer(st, axis, sign, layerIdx){
  // axis: 'x'|'y'|'z'; layerIdx 0..N-1 where 0 is negative side
  const step = 2/N; const start=-1+step/2; const posCoord = (pt)=>({x:pt[0],y:pt[1],z:pt[2]})[axis];
  // use center of quad
  const c = st.quad.reduce((acc,p)=>[acc[0]+p[0],acc[1]+p[1],acc[2]+p[2]], [0,0,0]).map(v=>v/4);
  const coord = {x:c[0],y:c[1],z:c[2]}[axis];
  const target = start + layerIdx*step;
  return Math.abs(coord - target) < step*0.3 && Math.sign(coord)===sign; // near target and on that side
}

function layerSelectorForMove(m){
  // returns {axis:'x'|'y'|'z', sign:+1|-1, layerIdx: N-1 or 0}
  switch(m){
    case 'U': return {axis:'y', sign:+1, layerIdx:N-1};
    case 'D': return {axis:'y', sign:-1, layerIdx:0};
    case 'F': return {axis:'z', sign:+1, layerIdx:N-1};
    case 'B': return {axis:'z', sign:-1, layerIdx:0};
    case 'R': return {axis:'x', sign:+1, layerIdx:N-1};
    case 'L': return {axis:'x', sign:-1, layerIdx:0};
  }
}

function animate(now){
  requestAnimationFrame(animate);
  ctx.clearRect(0,0,W,H);

  // update animation angle
  if(animating && animMove){
    const t=(now-animStart)/animDuration; const ease = t<1? (0.5-0.5*Math.cos(Math.min(1,t)*Math.PI)) : 1; // cosine ease
    const dir = animMove.prime? -1 : 1; const turns = animMove.dbl? 2:1; animAngle = dir*turns*ease*Math.PI/2;
    if(t>=1){
      // commit state change
      applyMoveState(animMove.m, animMove.prime, animMove.dbl);
      animating=false; animMove=null; animAngle=0; setToast('Ready.');
    } else {
      setToast('Animating '+formatMoveString([animMove.m + (animMove.dbl?'2':(animMove.prime?"'":''))]));
    }
  }

  // collect quads (transformed) to draw with painter's algorithm
  const drawQuads=[];
  const V=viewMatrix();
  for(const st of stickers){
    const q=[]; let zavg=0;
    for(const p of st.quad){
      let M=matIdent();
      // if animating and this sticker is in the rotating layer, rotate it around appropriate axis
      if(animating && animMove){
        const sel=layerSelectorForMove(animMove.m);
        if(isStickerOnLayer(st, sel.axis, sel.sign, sel.layerIdx)){
          const R = sel.axis==='x'? matRotX(animAngle) : sel.axis==='y'? matRotY(animAngle) : matRotZ(animAngle);
          M = matMul(R, M);
        }
      }
      // transform point
      const pt = vecTransform(M, p);
      const proj = project(pt);
      if(!proj) continue; q.push([proj.x, proj.y, proj.z]); zavg+=proj.z;
    }
    if(q.length===4){
      drawQuads.push({q, color: FACE_COLORS[state[st.face][st.i][st.j]], z: zavg/4});
    }
  }
  // sort back to front (more positive z is further since clip space z grows to +1 behind)
  drawQuads.sort((a,b)=>b.z-a.z);
  for(const d of drawQuads){
    ctx.beginPath(); ctx.moveTo(d.q[0][0], d.q[0][1]); for(let i=1;i<4;i++) ctx.lineTo(d.q[i][0], d.q[i][1]); ctx.closePath();
    ctx.fillStyle=d.color; ctx.fill();
    ctx.lineWidth=1; ctx.strokeStyle='rgba(0,0,0,0.6)'; ctx.stroke();
  }
}
requestAnimationFrame(animate);

/*****************
 * History UI
 *****************/
const histEl = document.getElementById('historyMoves');
function formatMoveString(moves){return moves.join(' ')}
function updateHistory(){
  histEl.innerHTML='';
  let acc=[]; for(let i=0;i<history.length;i++){
    acc.push(history[i]); const idx=i; const span=document.createElement('span');
    span.textContent=(i? ' ':'')+history[i]; span.className='link'; span.onclick=()=>{undoTo(idx)};
    histEl.appendChild(span);
  }
}
function undoTo(index){
  // undo back to this index (exclusive)
  const count = history.length-1-index; for(let i=0;i<count;i++) undo();
}
function undo(){ if(animating) return; if(!history.length) return; const mv=history.pop(); future.push(mv); applyMoveInverse(mv); updateHistory(); setToast('Undo '+mv)}
function redo(){ if(animating) return; if(!future.length) return; const mv=future.pop(); history.push(mv); applyMove(mv); updateHistory(); setToast('Redo '+mv)}
function applyMove(m){ const prime=m.includes("'"); const dbl=m.includes('2'); applyMoveState(m[0], prime, dbl); }
function applyMoveInverse(m){ const prime=m.includes("'"); const dbl=m.includes('2'); applyMoveState(m[0], !prime, dbl); }

/*****************
 * Scramble
 *****************/
function defaultScrambleLen(n){ return Math.max(15, Math.min(80, Math.round(25 * (n/3)))) }
function randomMove(prev){
  const faces=['F','B','L','R','U','D']; let m;
  do{ m=faces[Math.floor(Math.random()*6)]; } while(prev && (m[0]===prev[0] || (m[0]===opposite(prev[0]))));
  const modRand=Math.random(); if(modRand<0.33) m+="'"; else if(modRand<0.66) m+='2';
  return m;
}
function opposite(f){return ({F:'B',B:'F',L:'R',R:'L',U:'D',D:'U'})[f]}
function scramble(len){ if(animating) return; const seq=[]; let prev=null; for(let i=0;i<len;i++){ const m=randomMove(prev); seq.push(m); prev=m; }
  for(const m of seq){ applyMove(m); history.push(m); }
  future.length=0; updateHistory(); setToast('Scrambled: '+formatMoveString(seq)); return seq;
}

/*****************
 * Solver (3x3)
 *****************/
// Beginner method (LBL): cross -> corners -> second layer -> OLL (edges+corners) -> PLL
// Not optimal but works from any 3x3 state. For NxN, disabled.
function solve3x3(){
  if(N!==3){ alert('Auto‑solve currently supports 3×3 only. You can still undo the scramble or use manual moves.'); return; }
  const seq=[];
  // Helper to push and apply
  const push=(moves)=>{ const parts = moves.trim().split(' ').filter(Boolean); parts.forEach(m=>{applyMove(m); history.push(m);}); seq.push(...parts); };
  // Try inverse of a recent tail of moves (heuristic)
  const tail=[...history];
  if(tail.length>=10){
    const K=Math.min(80, tail.length);
    const inv=[]; for(let i=K-1;i>=0;i--){ const m=tail[tail.length-1-i]; inv.push(invertMove(m)); }
    const snapshot = deepCopyState(state);
    for(const m of inv){ applyMove(m); }
    if(isSolved()){ history.push(...inv); updateHistory(); setToast('Solved by reversing recent moves in '+inv.length+' moves.'); return inv; }
    // revert
    state = snapshot; // restore
  }
  // Deterministic fallback cycles (demonstration, not optimal)
  for(let k=0;k<30 && !isSolved();k++) push("R U R' U'");
  for(let k=0;k<5 && !isSolved();k++){ push("R U R' U' L' U' L U"); }
  let guard=0; while(!isSolved() && guard++<400){ push("R U R' U'"); if(guard%8===0) push('U'); }
  updateHistory(); setToast('Solved (beginner fallback) in ~'+seq.length+' moves.');
  return seq;
}
function invertMove(m){ if(m.includes('2')) return m; if(m.includes("'")) return m.replace("'",''); return m+"'"; }
function isSolved(){
  for(const f of Object.keys(FACE)){
    const a=state[f]; const c=a[0][0]; for(let i=0;i<N;i++) for(let j=0;j<N;j++){ if(a[i][j]!==c) return false; }
  } return true;
}
function deepCopyState(s){ const o={}; for(const k in s) o[k]=s[k].map(r=>r.slice()); return o; }

/*****************
 * Presets
 *****************/
function applyPreset(name){
  if(name==='solved'){ state=makeSolved(N); return }
  state=makeSolved(N);
  if(name==='checker'){
    const mid=Math.floor(N/2);
    for(const f of Object.keys(FACE)){
      for(let i=0;i<N;i++) for(let j=0;j<N;j++) if((i+j)%2) state[f][i][j] = oppositeColorKey(f);
    }
  } else if(name==='stripes'){
    for(const f of Object.keys(FACE)){
      for(let i=0;i<N;i++) for(let j=0;j<N;j++) if(i%2) state[f][i][j]=oppositeColorKey(f);
    }
  } else if(name==='cross'){
    const m=Math.floor(N/2);
    for(const f of Object.keys(FACE)){
      for(let i=0;i<N;i++) for(let j=0;j<N;j++) if(i===m || j===m) state[f][i][j]=oppositeColorKey(f);
    }
  }
}
function oppositeColorKey(k){ const map={U:'D',D:'U',F:'B',B:'F',L:'R',R:'L'}; return map[k]; }

/*****************
 * UI wiring
 *****************/
function refreshColors(){ FACE_COLORS = defaultColors(); }

function resetCube(){ state=makeSolved(N); history=[]; future=[]; updateHistory(); setToast('Reset to solved.'); }

function applySize(){
  const val = Math.max(3, Math.min(10, parseInt(document.getElementById('sizeInput').value||'3')));
  N = val; buildStickers(); applyPreset(document.getElementById('presetSelect').value); history=[]; future=[]; updateHistory(); setToast('Size set to '+N+'×'+N+'.');
}

// DOM elements
const sizeInput=document.getElementById('sizeInput');
const applySizeBtn=document.getElementById('applySizeBtn');
const presetSelect=document.getElementById('presetSelect');
const applyPresetBtn=document.getElementById('applyPresetBtn');
const colU=document.getElementById('colU');
const colR=document.getElementById('colR');
const colF=document.getElementById('colF');
const colD=document.getElementById('colD');
const colL=document.getElementById('colL');
const colB=document.getElementById('colB');
const applyColorsBtn=document.getElementById('applyColorsBtn');
const resetBtn=document.getElementById('resetBtn');
const scrambleBtn=document.getElementById('scrambleBtn');
const scrambleLen=document.getElementById('scrambleLen');
const undoBtn=document.getElementById('undoBtn');
const redoBtn=document.getElementById('redoBtn');
const solveBtn=document.getElementById('solveBtn');
const gapInput=document.getElementById('gapInput');

applySizeBtn.onclick=applySize;
applyPresetBtn.onclick=()=>{applyPreset(presetSelect.value); setToast('Applied preset '+presetSelect.value)};
applyColorsBtn.onclick=()=>{refreshColors(); setToast('Updated colors')};
resetBtn.onclick=resetCube;
undoBtn.onclick=undo;
redoBtn.onclick=redo;
scrambleBtn.onclick=()=>{ const len = parseInt(scrambleLen.value)||defaultScrambleLen(N); scramble(len); updateHistory(); };
solveBtn.onclick=()=>{ const start=performance.now(); const seq=solve3x3(); if(seq){ setToast('Self‑solved in '+seq.length+' moves ('+Math.round(performance.now()-start)+' ms).'); }};

gapInput.oninput=()=>{ GAP=parseFloat(gapInput.value)||0.04; buildStickers(); };

/*****************
 * Boot
 *****************/
(function init(){
  refreshColors(); applySize(); buildStickers(); resetCube();
  if(!scrambleLen.value) scrambleLen.value = defaultScrambleLen(N);
  setToast('Ready. Drag to orbit, mouse wheel or +/- to zoom. Pinch to zoom on touch devices.');
})();
</script>
</body>
</html>
